# -*- coding: utf-8 -*-
"""Weather_2_Scra.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1L3SU7Cr3dTox5HAhFtNQQS-3rPJQS_5y
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import tensorflow as tf
from tensorflow import keras
from matplotlib import pyplot as plt
from sklearn import preprocessing
# %matplotlib inline

!git clone 'https://github.com/sachinkavindaa/Machine-learning-with-Python'

df = pd.read_csv('/content/Machine-learning-with-Python/ML/Weather/Weather_3/Weather.csv')
df.head()

merged = df[['T_Max', 'T_Min', 'Wind', 'Could','Precip','Humidity','Pressure']]
merged.head()

def min_max_scaling(merged):
    # copy the dataframe
    df_norm = merged.copy()
    # apply min-max scaling
    for column in df_norm.columns:
        df_norm[column] = (df_norm[column] - df_norm[column].min()) / (df_norm[column].max() - df_norm[column].min())
        
    return df_norm
    
# call the min_max_scaling function
df_scaled = min_max_scaling(merged)

df_scaled

from sklearn.model_selection import train_test_split
X_train,X_test,y_train,y_test = train_test_split(df_scaled[['T_Max', 'T_Min', 'Wind', 'Could','Humidity','Pressure']],df_scaled.Precip,test_size =0.2,random_state=25)

X_train_scaled = X_train.copy()
X_train_scaled[['T_Max', 'T_Min', 'Wind', 'Could','Humidity','Pressure']]= X_train_scaled[['T_Max', 'T_Min', 'Wind', 'Could','Humidity','Pressure']]

X_test_scaled = X_test.copy()
X_test_scaled[['T_Max', 'T_Min', 'Wind', 'Could','Humidity','Pressure']]= X_test_scaled[['T_Max', 'T_Min', 'Wind', 'Could','Humidity','Pressure']]
_

model = keras.Sequential([
    keras.layers.Dense(1, input_shape=(6,), activation='sigmoid', kernel_initializer='ones', bias_initializer='zeros')
])

model.compile(optimizer='adam',
              loss='binary_crossentropy',
              metrics=['accuracy'])

model.fit(X_train_scaled, y_train, epochs=5000)

model.evaluate(X_test_scaled,y_test)

model.predict(X_test_scaled)

def sigmoid_numpy(X):
   return 1/(1+np.exp(-X))

sigmoid_numpy(np.array([12,0,1,6,3,9]))

def log_loss(y_true, y_predicted):
    epsilon = 1e-15
    y_predicted_new = [max(i,epsilon) for i in y_predicted]
    y_predicted_new = [min(i,1-epsilon) for i in y_predicted_new]
    y_predicted_new = np.array(y_predicted_new)
    return -np.mean(y_true*np.log(y_predicted_new)+(1-y_true)*np.log(1-y_predicted_new))

class myNN:
    def __init__(self):
        self.w1 = 1 
        self.w2 = 1
        self.w3 = 1
        self.w4 = 1
        self.w5 = 1
        self.w6 = 1
        self.bias = 0
        
    def fit(self, X, y, epochs, loss_thresold):
         self.w1, self.w2, self.w3, self.w4, self.w5, self.w6, self.bias = self.gradient_descent(X['T_Max'],X['T_Min'],X['Wind'],X['Could'],X['Humidity'],
                                                                                                 X['Pressure'],y, epochs, loss_thresold)
         
         print(f"Final weights and bias: w1: {self.w1}, w2: {self.w2}, w3: {self.w3}, w4: {self.w4},  w5: {self.w5}, w6: {self.w6} , bias: {self.bias}")
        
    def predict(self, X_test):
        weighted_sum = self.w1*X_test['T_Max'] + self.w2*X_test['T_Min'] + self.w3*X_test['Wind'] + self.w4*X_test['Could']+self.w5*X_test['Humidity']
        + self.w6*X_test['Pressure'] + self.bias
        return sigmoid_numpy(weighted_sum)

    def gradient_descent(self, T_Max, T_Min, Wind, Could, Pressure, Humidity, y_true, epochs, loss_thresold):
        w1 = w2= w3 =w4 = w5 = w6 = 1
        bias = 0
        rate = 0.5
        n = len(Wind)
        for i in range(epochs):
            weighted_sum = w1 * T_Max + w2* T_Min + w3* Wind + w4* Could + w5* Pressure + w6* Humidity + bias
            y_predicted = sigmoid_numpy(weighted_sum)
            loss = log_loss(y_true, y_predicted)
            
            w1d = (1/n)*np.dot(np.transpose(T_Max),(y_predicted-y_true)) 
            w2d = (1/n)*np.dot(np.transpose(T_Min),(y_predicted-y_true)) 
            w3d = (1/n)*np.dot(np.transpose(Wind),(y_predicted-y_true)) 
            w4d = (1/n)*np.dot(np.transpose(Could),(y_predicted-y_true)) 
            w5d = (1/n)*np.dot(np.transpose(Pressure),(y_predicted-y_true)) 
            w6d = (1/n)*np.dot(np.transpose(Humidity),(y_predicted-y_true)) 

            bias_d = np.mean(y_predicted-y_true)
            w1 = w1 - rate * w1d
            w2 = w2 - rate * w2d
            w3 = w3 - rate * w3d
            w4 = w4 - rate * w4d
            w5 = w5 - rate * w5d
            w6 = w6 - rate * w6d   

            
            bias = bias - rate * bias_d
            
            if i%50==0:
                print (f'Epoch:{i}, w1:{w1}, w2:{w2}, w3:{w3}, w4:{w4}, w5:{w5}, w6:{w6} , bias:{bias}, loss:{loss}')
            
           
                
        return w1, w2, w3, w4, w5, w6, bias

customModel = myNN()
customModel.fit(X_train_scaled, y_train, epochs=8000, loss_thresold=0.9631)

customModel.predict(X_test_scaled)

model.predict(X_test_scaled)

